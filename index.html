<!doctype html>
<html>
  <head>
    <title>PXL Editor</title>
    <link rel="icon" href="/511/257/341/313/381/313/341/257/511.svg"/>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      a {
        text-decoration: none;
      }
      a:hover {
        opacity: 0.75;
      }
      a:active {
        opacity: 0.5;
      }
      a img {
        height: 32px;
      }
      .mr-1 {
        margin-right: 1em;
      }
      .container {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        background-color: rgb(7, 7, 7);
      }
      .cvs {
        cursor: pointer;
      }
      #menu {
        position: fixed;
        top: 16px;
        right: 16px;
      }
      #c {
        position: fixed;
        bottom: 8px;
        right: 16px;
      }
      [hidden] {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <canvas id="cvs" class="cvs"></canvas>
    </div>
    <div id="menu">
      <a id="fsc" href="#" title="Fullscreen">
        <img src="/511/257/365/325/257/325/365/257/511.svg"/>
      </a>
      <a id="mns" href="#" title="Zoom Out (Ctrl + -)">
        <img src="/255/129/129/129/189/129/129/129/255.svg"/>
      </a>
      <a id="pls" class="mr-1" href="#" title="Zoom In (Ctrl + +)">
        <img src="/511/257/273/273/381/273/273/257/511.svg"/>
      </a>
      <a id="prv" href="#" title="Undo (Ctrl + Z)">
        <img src="/127/65/81/89/93/89/81/65/127.svg"/>
      </a>
      <a id="nxt" class="mr-1" href="#" title="Redo (Ctrl + Shift + Z)">
        <img src="/127/65/69/77/93/77/69/65/127.svg"/>
      </a>
      <a id="fgr" href="#" title="Choose Foreground Color">
        <img src="/511/257/285/381/349/329/377/257/511.svg"/>
      </a>
      <a id="bgr" class="mr-1" href="#" title="Choose Background Color">
        <img src="/511/257/285/373/381/377/377/257/511.svg"/>
      </a>
      <a id="inv" href="#" title="Invert (Ctrl + I)">
        <img src="/2047/1025/1505/1445/1325/1445/1505/1025/2047.svg"/>
      </a>
      <a id="mrh" href="#" title="Mirror H (Ctrl + .)">
        <img src="/511/257/273/273/341/273/273/257/511.svg"/>
      </a>
      <a id="mrv" href="#" title="Mirror V (Ctrl + ,)">
        <img src="/511/257/273/257/381/257/273/257/511.svg"/>
      </a>
      <a id="clr" class="mr-1" href="#" title="Clear (Ctrl + Q)">
        <img src="/511/257/365/313/273/313/365/257/511.svg"/>
      </a>
      <a id="txt" href="#" title="TXT">
        <img src="/32767/16385/23901/18761/18569/18761/18761/16385/32767.svg"/>
      </a>
      <a id="svg" href="#" title="SVG">
        <img src="/262143/131073/193629/136261/186077/168849/192797/131073/262143.svg"/>
      </a>
      <a id="png" href="#" title="PNG (Ctrl + Enter)">
        <img src="/131071/65537/96861/68309/93149/84805/96837/65537/131071.svg"/>
      </a>
    </div>
    <div id="c">
      <a href="/34359738367/34091302913/34220502845/34120098669/34154178413/34120360813/34220502845/17179869185/25565293965/24542670301/24542670253/25616412045/24491556237/17179869185/34359738367.png" title="Copyright">
        <img src="/255/129/153/165/133/165/153/129/255.svg"/>
      </a>
    </div>
    <div id="pck" class="container" hidden>
      <canvas class="cvs"></canvas>
    </div>
    <script>
      'use strict';

      class World {
        constructor(bits) {
          this.bits = bits;
          this.rows = new BigUint64Array(this.bits);
        }

        get(x, y) {
          return (this.rows[y] & (1n<<BigInt(x))) !== 0n;
        }

        set(x, y, val) {
          if (val) {
            this.rows[y] |= (1n<<BigInt(x));
          } else {
            this.rows[y] &= ~(1n<<BigInt(x));
          }
          return val;
        }

        toggle(x, y) {
          return this.set(x, y, !this.get(x, y));
        }

        invert() {
          this.rows = this.rows.map((val) => (~val) & ((1n<<BigInt(this.bits)) - 1n));
        }

        mirror() {
          this.rows = this.rows.map((val) => {
            let res = 0n;

            for (let i = 0; i < this.bits; i++) {
              res <<= 1n;
              res |= val & 1n;
              val >>= 1n;
            }
            return res;
          });
        }

        reverse() {
          this.rows.reverse();
        }

        reset(rows = []) {
          for (let i = 0; i < this.rows.length; i++) {
            this.rows[i] = (rows[i] === undefined) ? 0n : rows[i];
          };
        }

        resetPath(path = '') {
          const rows = path.slice(1).split('/').map((s) => {
            try {
              return BigInt(s);
            } catch {
              return 0n;
            }
          });

          this.reset(rows);
        }

        get path() {
          return `/${this.rows.join('/')}`;
        }

        compactRows() {
          const rows = [...this.rows];
          // Remove leading empty rows.
          let index = rows.findIndex((val) => val > 0);
          if (index < 0) return [];
          rows.splice(0, index);
          // Remove trailing empty rows.
          rows.reverse();
          rows.splice(0, rows.findIndex((val) => val > 0));
          rows.reverse();
          // Remove leading empty cols.
          const min = rows
            .filter((val) => val > 0)
            .map((val) => val & ((~val) + 1n))
            .reduce((memo, val) => (memo < val) ? memo : val);
          return (min === 0) ? rows : rows.map((val) => val / min);
        }

        get compactPath() {
          const rows = this.compactRows();
          return (rows.length === 0) ? null : `/${rows.join('/')}`;
        }
      };

      class Canvas {
        static get zoomStep() {
          return 1.5;
        }

        constructor(el, bits, width, height) {
          this.el = el;
          this.bits = bits;
          this.ctx = this.el.getContext('2d');
          this.resize(width, height);
        }

        resize(width, height) {
          const size = Math.max(width, height);
          this.scale = Math.ceil(size / this.bits);
          this.el.width = this.bits * this.scale;
          this.el.height = this.bits * this.scale;
        }

        zoomIn() {
          this.resize(
            this.el.width * Canvas.zoomStep,
            this.el.height * Canvas.zoomStep,
          );
        }

        zoomOut() {
          this.resize(
            this.el.width / Canvas.zoomStep,
            this.el.height / Canvas.zoomStep,
          );
        }

        draw(x, y, fill, stroke = 'rgb(7, 7, 7)') {
          this.ctx.fillStyle = fill;
          this.ctx.strokeStyle = stroke;
          this.ctx.beginPath();
          this.ctx.rect(x*this.scale, y*this.scale, this.scale, this.scale);
          this.ctx.fill();
          this.ctx.stroke();
          this.ctx.closePath();
        }

        rgba(x, y) {
          const realX = (x * this.scale) + (this.scale / 2);
          const realY = (y * this.scale) + (this.scale / 2);
          return this.ctx.getImageData(realX, realY, 1, 1).data;
        }

        coords(x, y) {
          return [
            Math.trunc((x - this.el.offsetLeft) / this.scale),
            Math.trunc((y - this.el.offsetTop) / this.scale),
          ];
        }
      };

      class Color {
        constructor(r, g, b, a) {
          this.r = r;
          this.g = g;
          this.b = b;
          this.a = a;
        }

        get css() {
          return `rgba(${this.r}, ${this.g}, ${this.b}, ${this.a / 255})`;
        }

        get pxl() {
          let pxl = 0n;
          pxl |= BigInt(this.r) << 24n;
          pxl |= BigInt(this.g) << 16n;
          pxl |= BigInt(this.b) << 8n;
          pxl |= BigInt(this.a) << 0n;
          return pxl;
        }
      }

      class Cursor {
        constructor(world, canvas, colors) {
          this.world = world;
          this.canvas = canvas;
          this.colors = colors;
          this.x = Math.trunc(bits / 2);
          this.y = Math.trunc(bits / 2);
          this.isDown = false;
          this.blinker = null;
          this._blink(this.x, this.y);
        }

        _mvTo(x, y, draw = false) {
          // Check bounds.
          if (x < 0 || this.world.bits <= x || y < 0 || this.world.bits <= y) return false;
          // Do nothing if the cursor didn't move.
          if (x === this.x && y === this.y) return false;
          // Reset prev cell.
          this._reset(this.x, this.y);
          // Move to new location.
          this.x = x;
          this.y = y;
          // Reset blinker.
          this._blink(this.x, this.y)
          // Are we done?
          if (!draw && !this.isDown) return false;
          // Draw if cursor is down.
          this._toggle(this.x, this.y);
          return true;
        }

        mvTo(pageX, pageY, draw = false) {
          const [x, y] = this.canvas.coords(pageX, pageY);
          this._mvTo(x, y, draw);
        }

        mvUp(draw = false) {
          return this._mvTo(this.x, this.y - 1, draw);
        }

        mvDown(draw = false) {
          return this._mvTo(this.x, this.y + 1, draw);
        }

        mvLeft(draw = false) {
          return this._mvTo(this.x - 1, this.y, draw);
        }

        mvRight(draw = false) {
          return this._mvTo(this.x + 1, this.y, draw);
        }

        up() {
          this.isDown = false;
        }

        down() {
          this._toggle(this.x, this.y);
          this.isDown = true;
        }

        draw() {
          this._toggle(this.x, this.y);
        }

        async flush() {
          for (let x = 0; x < this.world.bits; x++) {
            for (let y = 0; y < this.world.bits; y++) {
              this._reset(x, y);
            }
          }
        }

        set fg(fg) {
          this.colors.fg = fg;
        }

        get fg() {
          return this.colors.fg;
        }

        set bg(bg) {
          this.colors.bg = bg;
        }

        get bg() {
          return this.colors.bg;
        }

        _reset(x, y) {
          this.canvas.draw(x, y, this.world.get(x, y) ? this.colors.fg.css : this.colors.bg.css);
        }

        _toggle(x, y) {
          this.canvas.draw(x, y, this.world.toggle(x, y) ? this.colors.fg.css : this.colors.bg.css);
        }

        _blink(x, y) {
          let blink = false;
          this.canvas.draw(x, y, this.colors.bl.css);
          window.clearInterval(this.blinker);

          this.blinker = window.setInterval(() => {
            blink ? this.canvas.draw(x, y, this.colors.bl) : this._reset(x, y);
            blink = !blink;
          }, 500);
        }
      };

      class ColorPicker {
        constructor(canvas, lightness = 0.5) {
          this.canvas = canvas;
          this.lightness = lightness;
          this._flush();
        }

        color(x, y) {
          return new Color(...this.canvas.rgba(x, y));
        }

        coords(pageX, pageY) {
          return this.canvas.coords(pageX, pageY);
        }

        async _flush() {
          for (let x = 0; x < this.canvas.bits; x++) {
            for (let y = 0; y < this.canvas.bits; y++) {
              const [h, s, l] = this._hsl(x, y);
              this.canvas.draw(x, y, `hsl(${h}, ${s*100}%, ${l*100}%)`);
            }
          }
        }

        _hsl(x, y) {
          const [r, phi] = this._polarCoords(x, y);
          const h = (phi * 180) / Math.PI;
          const s = r / this._radius(this.canvas.bits, this.canvas.bits);
          const l = this.lightness;
          return [h, s, l];
        }

        _polarCoords(x, y) {
          return [this._radius(x, y), this._angle(x, y)];
        }

        _radius(x, y) {
          const [pX, pY] = this._translate(x, y);
          return Math.sqrt(pX**2 + pY**2)
        }

        _angle(x, y) {
          const [pX, pY] = this._translate(x, y);
          const atan = Math.atan(pY / pX);
          if (pX >= 0 && pY >= 0) return atan;
          if (pX < 0) return atan + Math.PI;
          return atan + (2 * Math.PI);
        }

        _translate(x, y) {
          return [
            x - (this.canvas.bits / 2),
            y - (this.canvas.bits / 2),
          ];
        }
      };

      const defaultRows = [
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        0n,
        92360817901568n,
        61574382747648n,
        136341089550336n,
        61574383271936n,
        92362961715200n,
        0n,
        138502828064768n,
        120616485519360n,
        120616486043648n,
        67839927386112n,
        120891314667520n,
      ];

      const bits = 64;

      const bg = new Color(0, 0, 0, 255);
      const fg = new Color(232, 52, 143, 255);
      const bl = new Color(116, 26, 72, 255);

      const fsc = document.getElementById('fsc');
      const mns = document.getElementById('mns');
      const pls = document.getElementById('pls');
      const prv = document.getElementById('prv');
      const nxt = document.getElementById('nxt');
      const fgr = document.getElementById('fgr');
      const bgr = document.getElementById('bgr');
      const inv = document.getElementById('inv');
      const mrh = document.getElementById('mrh');
      const mrv = document.getElementById('mrv');
      const clr = document.getElementById('clr');
      const txt = document.getElementById('txt');
      const svg = document.getElementById('svg');
      const png = document.getElementById('png');
      const cvs = document.getElementById('cvs');
      const pck = document.getElementById('pck');
      const pckCvs = pck.querySelector('.cvs');

      const world = new World(bits);
      const canvas = new Canvas(cvs, bits, window.innerWidth, window.innerHeight);
      const cursor = new Cursor(world, canvas, {bg, fg, bl});
      const picker = new ColorPicker(new Canvas(pckCvs, bits, window.innerWidth, window.innerHeight));

      const pushState = () => {
        window.history.pushState(null, document.title, `/#${world.path}`);
      };

      const popState = () => {
        const hash = window.location.hash.slice(1);
        (hash === '') ? world.reset(defaultRows) : world.resetPath(hash);
        cursor.flush();
      };

      popState();

      cvs.addEventListener('mouseup', () => cursor.up());
      cvs.addEventListener('mouseout', () => cursor.up());

      cvs.addEventListener('mousedown', (e) => {
        // Ignore right click.
        if (e.button === 2) return;
        e.preventDefault();
        cursor.down();
        pushState();
      });

      cvs.addEventListener('mousemove', (e) => {
        const update = cursor.mvTo(e.pageX, e.pageY, e.shiftKey);
        if (update) pushState();
      });

      pckCvs.addEventListener('click', (e) => {
        const [x, y] = picker.coords(e.pageX, e.pageY);
        pck.hidden = true;

        if (pck.dataset.g === 'fg') {
          cursor.fg = picker.color(x, y);
        } else {
          cursor.bg = picker.color(x, y);
        }
        cursor.flush();
      });

      fsc.addEventListener('click', (e) => {
        e.preventDefault();

        if (document.fullscreenElement === null) {
          document.body.requestFullscreen();
        } else {
          document.exitFullscreen();
        }
      });

      mns.addEventListener('click', (e) => {
        e.preventDefault();
        canvas.zoomOut();
        cursor.flush();
      });

      pls.addEventListener('click', (e) => {
        e.preventDefault();
        canvas.zoomIn();
        cursor.flush();
      });

      prv.addEventListener('click', (e) => {
        e.preventDefault();
        window.history.go(-1);
      });

      nxt.addEventListener('click', (e) => {
        e.preventDefault();
        window.history.go(1);
      });

      fgr.addEventListener('click', (e) => {
        e.preventDefault();
        pck.hidden = false;
        pck.dataset.g = 'fg';
      });

      bgr.addEventListener('click', (e) => {
        e.preventDefault();
        pck.hidden = false;
        pck.dataset.g = 'bg';
      });

      inv.addEventListener('click', (e) => {
        e.preventDefault();
        world.invert();
        cursor.flush();
        pushState();
      });

      mrh.addEventListener('click', (e) => {
        e.preventDefault();
        world.mirror();
        cursor.flush();
        pushState();
      });

      mrv.addEventListener('click', (e) => {
        e.preventDefault();
        world.reverse();
        cursor.flush();
        pushState();
      });

      clr.addEventListener('click', (e) => {
        e.preventDefault();
        world.reset();
        cursor.flush();
        pushState();
      });

      txt.addEventListener('click', (e) => {
        e.preventDefault();
        const path = world.compactPath;
        if (path !== null) window.location.href = `${path}.txt`;
      });

      svg.addEventListener('click', (e) => {
        e.preventDefault();
        const path = world.compactPath;
        if (path === null) return;
        window.location.href = `${path}.svg?fg=${cursor.fg.pxl}&bg=${cursor.bg.pxl}`;
      });

      png.addEventListener('click', (e) => {
        e.preventDefault();
        const path = world.compactPath;
        if (path === null) return;
        window.location.href = `${path}.png?fg=${cursor.fg.pxl}&bg=${cursor.bg.pxl}`;
      });

      window.addEventListener('popstate', (e) => {
        e.preventDefault();
        popState();
      });

      window.addEventListener('resize', () => {
        canvas.resize(window.innerWidth, window.innerHeight);
        cursor.flush();
      });

      window.addEventListener('keydown', (e) => {
        switch (e.key) {
          case 'ArrowDown':
            e.preventDefault();
            if(cursor.mvDown(e.shiftKey)) pushState();
            return;
          case 'ArrowUp':
            e.preventDefault();
            if(cursor.mvUp(e.shiftKey)) pushState();
            return;
          case 'ArrowRight':
            e.preventDefault();
            if(cursor.mvRight(e.shiftKey)) pushState();
            return;
          case 'ArrowLeft':
            e.preventDefault();
            if(cursor.mvLeft(e.shiftKey)) pushState();
            return;
          case 'Shift':
            e.preventDefault();
            cursor.draw();
            pushState();
            return;
        }

        if (!e.ctrlKey) return;

        switch (e.key) {
          case '-':
            e.preventDefault();
            canvas.zoomOut();
            cursor.flush();
            return;
          case '+':
            e.preventDefault();
            canvas.zoomIn();
            cursor.flush();
            return;
          case '.':
            e.preventDefault();
            world.mirror();
            cursor.flush();
            pushState();
            return;
          case ',':
            e.preventDefault();
            world.reverse();
            cursor.flush();
            pushState();
            return;
          case '0':
            e.preventDefault();
            canvas.resize(window.innerWidth, window.innerHeight);
            cursor.flush();
            return;
          case 'i':
            e.preventDefault();
            world.invert();
            cursor.flush();
            pushState();
            return;
          case 'q':
            e.preventDefault();
            world.reset();
            cursor.flush();
            pushState();
            return;
          case 'Enter':
            e.preventDefault();
            window.location.href = world.compactPath;
            return;
          case 'z':
            e.preventDefault();
            window.history.go(-1);
            return;
          case 'Z':
            e.preventDefault();
            window.history.go(1);
            return;
        }
      });
    </script>
  </body>
</html>
